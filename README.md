# gpii-signing-poc

Experiment for [GPII-3801](https://issues.gpii.net/browse/GPII-3081) - running GPII at the high integrity level.

## Build

### Generate the certificate

    generate-cert.ps1

This will produce:

* `code-sign-test.cert`: The test certificate, can be distributed.
* `code-sign-test.pfx`: The private key (and certificate). Used to sign the executable, should not be distributed.
Password will be "`I'm only testing`".

### Build the executable

    build.bat

This will compile `SendMessage.exe`, and call `sign.ps1` to sign it.

`app.manifest` will be bundled into the executable to tell Windows to run at a higher integrity level. With this in
place, Windows will not run the executable unless it's in `c:\Program Files\`, `c:\Program Files (x86)\`, or
`c:\Windows\system32\`.

## Deploy

Take `SendMessage.exe`, `code-sign-test.cert`, and `trust-cert.ps1`. The `.pfx` file stays on where it was generated.

### Trust the certificate

On the machine where you wish to run the executable, as administrator run:

    trust-cert.ps1

Copy `SendMessage.exe` to somewhere in either `c:\Program Files\`, `c:\Program Files (x86)\`, or `c:\Windows\system32`.

(manually remove the certificate from the store when finished testing)

## Test

Get the window handle of something running at a high integrity level (AT or something running as admin, like regedit).

As a normal user, send WM_CLOSE to the window:

    SendMessage.exe <hwnd> 16 0 0

The window should close. To prove the whole thing isn't a waste of time, try an unsigned copy of `SendMessage.exe`
(generated by `cl SendMessage.c`).

## Notes

In production, the executable would be signed by a "real" certificate. The generate and trust steps will not be
required.
